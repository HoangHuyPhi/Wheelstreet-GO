//
//  AppetizerAPI.swift
//  Appetizer
//
//  Created by Kush Taneja on 21/06/17.
//  Copyright Â© 2017 Kush Taneja. All rights reserved.
//
<<<<<<< HEAD

=======
>>>>>>> c23dea6a61f2fe1a6c5e7e4309a7decdc72dabc4
/*
import UIKit

fileprivate enum Endpoints: String {
  case user = "user/"
  case login = "login/"
  case logout = "logout/"
  case me = "me/"
  case menu = "menu/"
  case week = "week/"
  case day = "day/"
  case feedbackTypes = "types/"
  case feedback = "feedback/"
  case response = "response/"
  case read = "read/"
  case count = "count/"
  case check = "check/"
  case leave = "leave/"
  case all = "all/"
  case reset = "reset/"
  case password = "password/"
  case confirm = "confirm/"
  case message = "message/"
  case list = "list/"
  case remaining = "remaining/"
  case help = "help/"
  case meal = "meal/"
  case faq = "faqs/"
}

class AppetizerAPI: AnyObject {

  static func statusToMessage(_ status: AppetizerAPIStatus) -> String {
    switch status {
    case .SUCCESS:
      return "Success"
    case .INVALID_CREDENTIALS:
      return "Invalid Credentials"
    case .NOT_AUTHORIDIZED:
      return "Session Timmed Out!"
    case .ERR_APP_HTTP_ERROR:
      return "Oh no, lost internet connection\n Please retry after some time."
    default:
      return "Looks like our servers cannot be reached. Be sure to check your internet connection."
    }
  }

  static func appetizerAPIStatus(_ code: Int) -> AppetizerAPIStatus {

    if 200 ... 299 ~= code {
      return AppetizerAPIStatus.SUCCESS
    }

    return AppetizerAPIStatus(rawValue: code) ?? .UNKOWN_ERROR
  }

  //MARK: Login

  class func attemptToLogin(enrollment: String, password: String, completion: @escaping((AppetizerAPIStatus)-> Void)) {

    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }

    let params: Dictionary<String,Any> = [AppetizerDefaultKeys.enrollmentKey: enrollment, AppetizerDefaultKeys.passwordKey: password]

    Network.shared.post(AppetizerURLs.serverURL + Endpoints.user.rawValue + Endpoints.login.rawValue, params: params, withHeader: false) { (data, code, error) in

      if let code = code {
        switch appetizerAPIStatus(code) {
        case .SUCCESS:
          guard let data = data,
            let token = data[AppetizerDefaultKeys.tokenKey].string,
            !token.isEmpty else {
              completion(.ERR_APP_HTTP_RESPONSE)
              return
          }

          UserDefaults.standard.set(token, forKey: AppetizerDefaultKeys.tokenKey)
          let groupDefaults = UserDefaults(suiteName: AppetizerDefaultKeys.appGroupsId)
          groupDefaults?.set(token, forKey: AppetizerDefaultKeys.tokenKey)
          AppetizerUser.saveUserInUserDefaults(JSONData: data)
          completion(.SUCCESS)
          return
        case .INVALID_CREDENTIALS:
          completion(.INVALID_CREDENTIALS)
          return
        default:
          break
        }
      }

      completion(.ERR_APP_HTTP_RESPONSE)
    }
  }

  class func attemptToLogout(completion: @escaping((AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }

    Network.shared.post(AppetizerURLs.serverURL + Endpoints.user.rawValue + Endpoints.logout.rawValue, params: nil, withHeader: true) { (data, code, error) in
      if let code = code {
        completion(appetizerAPIStatus(code))
        return
      }

      completion(.ERR_APP_HTTP_RESPONSE)
    }
  }

  //MARK: User

  class func reloadUserProfile(completion: @escaping()-> Void) {
    Network.shared.get(AppetizerURLs.serverURL + Endpoints.user.rawValue + Endpoints.me.rawValue, params: nil, withHeader: true) { (data, code, error) in

      if let code = code {
        switch appetizerAPIStatus(code) {
        case .SUCCESS:
          if let data = data {
            AppetizerUser.saveUserInUserDefaults(JSONData: data)
          }
          break
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          break
        }
        completion()
        return
      }
      else {
        completion()
      }
    }
  }

  class func updateUserDetails(updatedFields params: Dictionary<String, AnyObject>?, image: UIImage?, completion: @escaping((AppetizerAPIStatus)-> Void), progressBlock: @escaping(()-> Void)) {

      guard Reachability.isConnectedToNetwork() == true else {
        completion(.ERR_APP_HTTP_ERROR)
        return
      }

      if let image = image {
        Network.shared.uploadFileWithPatch(AppetizerURLs.serverURL + Endpoints.user.rawValue +  Endpoints.me.rawValue, image: image, imageName: "image", params: params, withHeader: true, completion: { (data, code, error) in
          if let code = code {
            completion(appetizerAPIStatus(code))
            return
          }
          completion(.UNKOWN_ERROR)
        }, progressBlock: { (fraction) in
          ActivityIndicator.shared.updateLablel(text: "\(fraction!*100) %")
          progressBlock()
        })
      }
      else {
        Network.shared.patch(AppetizerURLs.serverURL + Endpoints.user.rawValue +  Endpoints.me.rawValue, params: params, withHeader: true, completion: { (data, code, error) in
          if let code = code {
            completion(appetizerAPIStatus(code))
            return
          }
          completion(.UNKOWN_ERROR)
        })
      }
  }

  class func downloadImageFromUrl(_ url: URL, withHeader: Bool, completion: @escaping((UIImage?, AppetizerAPIStatus)-> Void)) {

    guard Reachability.isConnectedToNetwork() == true else {
      completion(nil, .ERR_APP_HTTP_ERROR)
      return
    }

    Network.shared.downloadImage(url, withHeader: withHeader) { (image, code, error) in
      completion(image, appetizerAPIStatus(code ?? 1000))
    }
  }

  //MARK: Menu

  class func getMenu(forWeekId id: Int, completion: @escaping((AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }

    let params: Dictionary<String, Any> = [AppetizerDefaultKeys.weekIdKey: id]

    Network.shared.get(AppetizerURLs.serverURL + Endpoints.menu.rawValue + Endpoints.week.rawValue, params: params, withHeader: true) { (data, code, error) in

      if let code = code {
        switch appetizerAPIStatus(code) {
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        case .SUCCESS:
          guard let data = data else {
            completion(.ERR_APP_HTTP_RESPONSE)
            return
          }

            let realm = try! Realm()
            let weekMenu = WeekMenu(data: data)
            try! realm.write {
              realm.create(WeekMenu.self, value: weekMenu, update: true)
            }
            completion(.SUCCESS)
            return
        default:
          completion(appetizerAPIStatus(code))
          return
        }
      }
      else {
        completion(.UNKOWN_ERROR)
      }
    }
  }


  class func getMealWithId(_ id: Int, completion: @escaping((Meal?, Error?)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      AppetizerViews.noInternetConnectionAlertView()
      completion(nil, AppetizerCommon.noInternetConnection())
      return
    }

    AppetizerViews.networkActivityIndicator(visible: true)

    Network.shared.get(AppetizerURLs.serverURL + Endpoints.menu.rawValue + Endpoints.meal.rawValue + "\(id)", params: nil, withHeader: true) { (data, code, error) in

      AppetizerViews.networkActivityIndicator(visible: false)

      if let error = error {
        completion(nil, error)
        return
      }

      guard let data = data else {
        completion(nil, AppetizerCommon.somethingWentWrong())
        return
      }

      var meal: Meal?
      meal = Meal(data: data)
      if let meal = meal {
        meal.mealItemsDataSource = MealItemDataSource(items: meal.items)
      }
      completion(meal, nil)
    }
  }

  //MARK: Feedback
  class func getfeedbackTypes(completion: @escaping(([FeedbackType]?, AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(nil, .ERR_APP_HTTP_ERROR)
      return
    }

    Network.shared.get(AppetizerURLs.serverURL + Endpoints.feedback.rawValue + Endpoints.feedbackTypes.rawValue, params: nil, withHeader: true) { (data, code, error) in
      if let code = code {
        switch appetizerAPIStatus(code) {
        case .SUCCESS:
          var feedbackTypes: [FeedbackType]?
          if let dataArray = data?.array {
            feedbackTypes = [FeedbackType]()
            for type in dataArray {
              let feedBackType = FeedbackType(JSONData: type)
              feedbackTypes?.append(feedBackType)
            }
            completion(feedbackTypes, .SUCCESS)
          }
          break
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          completion(nil, appetizerAPIStatus(code))
        }
      }
      else {
        completion(nil, .UNKOWN_ERROR)
      }
    }
  }

  class func sendEmail(email: String, completion: @escaping((AppetizerAPIStatus)-> Void)) {
    AppetizerViews.networkActivityIndicator(visible: true)
    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }

    let params: Dictionary<String, Any> = [AppetizerDefaultKeys.email: email]
    Network.shared.post(AppetizerURLs.serverURL + Endpoints.user.rawValue +  Endpoints.me.rawValue + Endpoints.password.rawValue + Endpoints.reset.rawValue, params: params, withHeader: false) { (data, code, error) in
      AppetizerViews.networkActivityIndicator(visible: false)
      if let code = code {
        switch appetizerAPIStatus(code) {
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          break
        }
        completion(appetizerAPIStatus(code))
        return
      }
      completion(.UNKOWN_ERROR)
    }
  }

  class func getfeedbackList(pageNumber: Int, pageSize: Int, completion: @escaping(([Feedback]?, _ hasMore: Bool?, AppetizerAPIStatus)-> Void)) {

    guard Reachability.isConnectedToNetwork() == true else {
      completion(nil, nil, .ERR_APP_HTTP_ERROR)
      return
    }

    let params: Dictionary<String, Any> = [AppetizerDefaultKeys.pageNumberKey: pageNumber , AppetizerDefaultKeys.pageSizeKey: pageSize]

    Network.shared.get(AppetizerURLs.serverURL + Endpoints.feedback.rawValue + Endpoints.all.rawValue, params: params, withHeader: true) { (data, code, error) in
      if let code = code {
        switch appetizerAPIStatus(code) {
        case .SUCCESS:
          var feedbacks: [Feedback]?
          var hasMore: Bool?
          if let data = data, let dataArray = data["results"].array {
            feedbacks = [Feedback]()
            for type in dataArray {
              let feedBack = Feedback(JSONData: type)
              feedbacks?.append(feedBack)
            }
            hasMore = data["has_next"].boolValue
          }
          completion(feedbacks, hasMore, .SUCCESS)
          break
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          completion(nil, nil, appetizerAPIStatus(code))
        }
      }
      else {
        completion(nil, nil, .UNKOWN_ERROR)
      }
    }
  }

  class func postFeedbackRequest(title: String, message: String, feedbackCode: String, mealID: Int? = nil, dateIssued: Int?, image: UIImage?, completion: @escaping((AppetizerAPIStatus)-> Void)) {

    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }

    var params: Dictionary<String, AnyObject> = [AppetizerDefaultKeys.typeKey: feedbackCode as AnyObject , AppetizerDefaultKeys.titleKey: title as AnyObject, AppetizerDefaultKeys.messageKey: message as AnyObject]

    if let mealID = mealID {
      params[AppetizerDefaultKeys.mealIDKey] = mealID as AnyObject
    }

    if let dateIssued = dateIssued {
      params[AppetizerDefaultKeys.dateIssueKey] = dateIssued as AnyObject
    }

    if let image = image {
      Network.shared.uploadFile(AppetizerURLs.serverURL + Endpoints.feedback.rawValue, image: image, imageName: "attachment", params: params, withHeader: true, completion: { (data, code, error) in
        if let code = code {
          switch appetizerAPIStatus(code) {
          case .NOT_AUTHORIDIZED:
            AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
            return
          default:
            break
          }
          completion(appetizerAPIStatus(code))
          return
        }
        completion(.UNKOWN_ERROR)
      }, progressBlock: { (fraction) in
        ActivityIndicator.shared.updateLablel(text: "\(fraction!*100) %")
      })
    }
    else {
      Network.shared.post(AppetizerURLs.serverURL + Endpoints.feedback.rawValue, params: params, withHeader: true, completion: { (data, code, error) in
        if let code = code {
          switch appetizerAPIStatus(code) {
          case .NOT_AUTHORIDIZED:
            AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
            return
          default:
            break
          }
          completion(appetizerAPIStatus(code))
          return
        }
        completion(.UNKOWN_ERROR)
      })
    }
  }

  class func getFeedback(forId id: Int, completion: @escaping((Feedback?, AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(nil, .ERR_APP_HTTP_ERROR)
      return
    }

    Network.shared.get(AppetizerURLs.serverURL + Endpoints.feedback.rawValue + "\(id)", params: nil, withHeader: true) { (data, code, error) in

      if let code = code {
        switch appetizerAPIStatus(code) {
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        case .SUCCESS:
          guard let data = data else {
            completion(nil, .ERR_APP_HTTP_RESPONSE)
            return
          }
          let feedback = Feedback(JSONData: data)
          completion(feedback, .SUCCESS)
        default:
          completion(nil, appetizerAPIStatus(code))
        }
      }
      else {
        completion(nil, .UNKOWN_ERROR)
      }
    }
  }

  class func changePassword(oldPassword: String, newPassword: String, completion: @escaping((AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }

    let params: Dictionary<String,Any> = [AppetizerDefaultKeys.oldPassword: oldPassword, AppetizerDefaultKeys.newPassword: newPassword ]

    Network.shared.put(AppetizerURLs.serverURL + Endpoints.user.rawValue + Endpoints.me.rawValue + Endpoints.password.rawValue, params: params, withHeader: true) { (data, code, error) in
      if let code = code {
        switch appetizerAPIStatus(code) {
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          break
        }
        completion(appetizerAPIStatus(code))
        return
      }
      completion(.UNKOWN_ERROR)
    }
  }

  class func changePasswordFromEmail(uidb64: String, token: String, newPassword: String, confirmPassword: String, completion: @escaping((AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }

    let params: Dictionary<String,Any> = [AppetizerDefaultKeys.uidb64: uidb64, AppetizerDefaultKeys.tokenKey: token, AppetizerDefaultKeys.newPassword: newPassword, AppetizerDefaultKeys.confirmPassword: confirmPassword]
    Network.shared.post(AppetizerURLs.serverURL + Endpoints.user.rawValue +  Endpoints.me.rawValue + Endpoints.password.rawValue + Endpoints.reset.rawValue + Endpoints.confirm.rawValue, params: params, withHeader: true) { (data, code, error) in
      if let code = code {
        switch appetizerAPIStatus(code) {
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          break
        }
        completion(appetizerAPIStatus(code))
        return
      }
      completion(.UNKOWN_ERROR)
    }
  }

  class func unreadFeedbackResponseCount(completion: @escaping((Int, AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(0, .ERR_APP_HTTP_ERROR)
      return
    }

    Network.shared.get(AppetizerURLs.serverURL + Endpoints.feedback.rawValue + Endpoints.response.rawValue + Endpoints.read.rawValue + Endpoints.count.rawValue, params: nil, withHeader: true) { (data, code, error) in
      if let code = code {
        switch appetizerAPIStatus(code) {
        case .SUCCESS:
          if let count = data?[AppetizerDefaultKeys.count].int {
            completion(count, .SUCCESS)
            return
          }
        default:
          completion(0, appetizerAPIStatus(code))
          return
        }
      }
      completion(0, .ERR_APP_HTTP_ERROR)
    }
  }

  class func markResponseAsReadFor(feedbackId id: Int) {
    guard Reachability.isConnectedToNetwork() == true else { return }
    Network.shared.post(AppetizerURLs.serverURL + Endpoints.feedback.rawValue + String(format: "%@/%@%@", "\(id)", Endpoints.response.rawValue, Endpoints.read.rawValue),
                        params: nil,
                        withHeader: true) { (data, code, error) in }
  }

  //MARK: Leaves

  class func postMealLeaveWithId(_ id: Int, completion: @escaping((AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }
    
    let params: Dictionary<String, Any> = [AppetizerDefaultKeys.mealsKey: [id]]
    Network.shared.post(AppetizerURLs.serverURL + Endpoints.leave.rawValue, params: params, withHeader: true) { (data, code, error) in
      if let code = code {
        switch appetizerAPIStatus(code) {
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          break
        }
        completion(appetizerAPIStatus(code))
        return
      }
      completion(.UNKOWN_ERROR)
    }
  }


  class func deleteMealLeaveWithId(_ id: Int, completion: @escaping((AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }

    Network.shared.delete(AppetizerURLs.serverURL + Endpoints.leave.rawValue + Endpoints.meal.rawValue + "\(id)", params: nil, withHeader: true) { (data, code, error) in
      if let code = code {
        switch appetizerAPIStatus(code) {
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          break
        }
        completion(appetizerAPIStatus(code))
        return
      }
      completion(.UNKOWN_ERROR)
    }
  }

  class func deleteLeave(_ id: Int, completion: @escaping((AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }

    Network.shared.delete(AppetizerURLs.serverURL + Endpoints.leave.rawValue + "\(id)", params: nil, withHeader: true) { (data, code, error) in
      if let code = code {
        switch appetizerAPIStatus(code) {
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          break
        }
        completion(appetizerAPIStatus(code))
        return
      }
      completion(.UNKOWN_ERROR)
    }
  }

  class func getLeaveHistory(pageNumber: Int, pageSize: Int, completion: @escaping(([MealLeave]?, _ hasMore: Bool?, AppetizerAPIStatus)-> Void)) {

    guard Reachability.isConnectedToNetwork() == true else {
      completion(nil, nil, .ERR_APP_HTTP_ERROR)
      return
    }

    let params: Dictionary<String, Any> = [AppetizerDefaultKeys.pageNumberKey: pageNumber , AppetizerDefaultKeys.pageSizeKey: pageSize]

    Network.shared.get(AppetizerURLs.serverURL + Endpoints.leave.rawValue + Endpoints.all.rawValue, params: params, withHeader: true) { (data, code, error) in

      if let code = code {
        switch appetizerAPIStatus(code) {
        case .SUCCESS:
          var mealLeaves: [MealLeave]?
          var hasMore: Bool?
          if let data = data, let dataArray = data["results"].array {
            mealLeaves = [MealLeave]()
            for type in dataArray {
              let mealLeave = MealLeave(JSONData: type)
              mealLeaves?.append(mealLeave)
            }
            hasMore = data["has_next"].boolValue
          }
          completion(mealLeaves, hasMore, .SUCCESS)
          break
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          completion(nil, nil, appetizerAPIStatus(code))
        }
      }
      else {
        completion(nil, nil, .UNKOWN_ERROR)
      }
    }
  }

  class func remaingLeavesCount(completion: @escaping((Int?, AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(nil, .ERR_APP_HTTP_ERROR)
      return
    }

    Network.shared.get(AppetizerURLs.serverURL + Endpoints.leave.rawValue + Endpoints.count.rawValue + Endpoints.remaining.rawValue, params: nil, withHeader: true) { (data, code, error) in

      if let code = code {
        switch appetizerAPIStatus(code) {
        case .SUCCESS:
          completion(data?[AppetizerDefaultKeys.count].intValue, .SUCCESS)
          return
        default:
          break
        }
        completion(nil, appetizerAPIStatus(code))
        return
      }
      completion(nil, .UNKOWN_ERROR)
    }
  }


  class func attemptToCheck(completion: @escaping((AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }

    Network.shared.post(AppetizerURLs.serverURL + Endpoints.leave.rawValue + Endpoints.check.rawValue, params: nil, withHeader: true) { (data, code, error) in

      if let code = code {
        switch appetizerAPIStatus(code) {
        case .SUCCESS:
          if let isCheckedOut = data?[AppetizerDefaultKeys.isCheckedOut].bool {
            AppetizerUserDefaultService.set(checkOut: isCheckedOut)
            completion(.SUCCESS)
            return
          }
        default:
          completion(appetizerAPIStatus(code))
          return
        }
      }
      completion(.ERR_APP_HTTP_ERROR)
    }
  }


  //MARK: Notifications

  class func getNotificationList(pageNumber: Int, pageSize: Int, completion: @escaping(([AppetizerRemoteNotification]?, _ hasMore: Bool?, AppetizerAPIStatus)-> Void)) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(nil, nil, .ERR_APP_HTTP_ERROR)
      return
    }

    let params: Dictionary<String, Any> = [AppetizerDefaultKeys.pageNumberKey: pageNumber , AppetizerDefaultKeys.pageSizeKey: pageSize]

    Network.shared.get(AppetizerURLs.serverURL + Endpoints.user.rawValue + Endpoints.message.rawValue + Endpoints.list.rawValue, params: params, withHeader: true) { (data, code, error) in
      if let code = code {
        switch appetizerAPIStatus(code) {
        case .SUCCESS:
          var notifications: [AppetizerRemoteNotification]?
          var hasMore: Bool?
          if let data = data, let dataArray = data["results"].array {
            notifications = [AppetizerRemoteNotification]()
            for notificationData in dataArray {
              let notification = AppetizerRemoteNotification(data: notificationData)
              notifications?.append(notification)
            }
            hasMore = data["has_next"].boolValue
          }
          completion(notifications, hasMore, .SUCCESS)
          break
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          completion(nil, nil, appetizerAPIStatus(code))
        }
      }
      else {
        completion(nil, nil, .UNKOWN_ERROR)
      }
    }
  }

  //MARK: FAQ

  class func getFAQList(completion: @escaping((AppetizerAPIStatus)-> Void)) {

    guard Reachability.isConnectedToNetwork() == true else {
      completion(.ERR_APP_HTTP_ERROR)
      return
    }

    Network.shared.get(AppetizerURLs.serverURL + Endpoints.faq.rawValue, params: nil, withHeader: true) { (data, code, error) in

      if let code = code {
        switch appetizerAPIStatus(code) {
        case .SUCCESS:
          if let dataArray = data?.array {
            for faqData in dataArray {
              let faq = FAQ(data: faqData)
              do {
                let realm = try Realm()

                try realm.write {
                  realm.create(FAQ.self, value: faq, update: true)
                }
              }
              catch {
                completion(.UNKOWN_ERROR)
              }
            }
          }
          completion(.SUCCESS)
          break
        case .NOT_AUTHORIDIZED:
          AppetizerCommon.logoutUser(status: .NOT_AUTHORIDIZED)
          return
        default:
          completion(appetizerAPIStatus(code))
        }
      }
      else {
        completion(.UNKOWN_ERROR)
      }
    }
  }

  //MARK: About
  class func getHelpText(completion: @escaping(String?, AppetizerAPIStatus)-> Void) {
    guard Reachability.isConnectedToNetwork() == true else {
      completion(nil, .ERR_APP_HTTP_ERROR)
      return
    }

    Network.shared.get(AppetizerURLs.serverURL + Endpoints.help.rawValue, params: nil, withHeader: false) { (data, code, error) in

      if let code = code {
        switch appetizerAPIStatus(code) {
        case .SUCCESS:
          if let helpContent = data?[AppetizerDefaultKeys.helpText].string {
            completion(helpContent, .SUCCESS)
            return
          }
          break
        default:
          break
        }
        completion(nil, appetizerAPIStatus(code))
    }
  }
}

}

<<<<<<< HEAD

=======
>>>>>>> c23dea6a61f2fe1a6c5e7e4309a7decdc72dabc4
*/
